\documentclass[10pt]{article}
\usepackage{amssymb}
\usepackage{lscape}
\usepackage[margin=.25in]{geometry}
\usepackage{fancyhdr}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{cancel}
\setlength\parindent{0pt}
\usepackage{adjustbox}
\usepackage[labelsep=quad, indention=10pt, position=bottom]{subfig}
\usepackage[latin1]{inputenc}
\pagestyle{fancy}
\lstset{
breaklines=true,
basicstyle=\tiny, %or \small or \footnotesize etc.
}
\begin{document}
\begin{landscape}
\begin{multicols*}{4}
\section{cis350 notes}
\scriptsize 
Definition of software engineering: The application of a systematic dsciplined quantifiable approach to the development , operation and mtainenance of software. e.g. Tom takes 12 hrs, ben takes 8 hrs. how long to both paint \textbf{4.8 hrs}. 
programming assumptions:  1) house tom and ben collected data on is the one they will paint (data collection of programmer output is inherently subjective). 2) homeowner wont change mind halfway thru painting (software requirements can and will change quickly). tom and ben have enough resources to never share it (shared software assets must be shared and maintained across multiple developers). 3) tom and ben will never do anything to slow each other down (never painting same thing twice, never going to pain another into a corner, ensuring most efficient. communication!) 4) no unforseen circumstances (what if market changes and product not needed) \textbf{biggest assumption is that there are no unexpeced mistakes}.
Programmers are bad at prediciting errors before they manifest. Software runs nearly every aspect of our lives and we know that software has been fault prone. software is custom built but errors can be hard to predict.
Engineering principles are \textbf{concepts rules or ideas to be kept in mind while solving an engineering problem}. no magic list, engineering principles are often earned thorugh mistakes and failures. principles can change in light of new challenges. SE is new and thus best principles are still being discovered. Bridge building example: they are becoming larger and more complex. Tacoma narrows bridge before collapse, builders thought lighter and narrower stuff was better for suspension. in the 1930s,aerodynaimics was poorly understood. forgot to consider vertical wind $\rightarrow$ destruction of tacoma narrows bridge.
Software princieples: use modern programming suites, when using 3rd party software, have contingency planes, ensure good modulaarizations, always document critical safety decisions. existing software is less risky than new custom software, use independent test teams when possible, code review can detect defts, always tes complete system within target environment .e.g gandhi bit overflow (-2 modifier to aggression normally, but when -1 overflows to 255 super agressive). modern compilers prevent this. heartbleed. navy social security leak. \textbf{Assessing risk} when you rely on third party software have risk assessment plan. should be identified and daddressed via \textit{avoidance, mitigation, having a contingency} esp w/regards to security. mars climate was lbs/sec vs newton/sec. NATS. old software can be costly (newer tech is cheaper and reduces error rates). as code ages, harder to maintain. \textbf{this is what software entropy is}. combatted with refactoring. \textbf{effort} refers to the time and money required to produce a piece of software. prediciting effort is diffficult. effort estimation resesarch provides models to predict time and cost of softare production. most use historical data and have wide margin of error. Therac-25 (no indep code review, unhelpful error messages, not testing with hardware and software together until in hospital). \textbf{importance of testing} is the best way to catch software ffailure is to find it in testing, can never be exhaustive, should mimic the end enviorment as much as possible, code reviews are often encouraged in conjucntion with testing. nothing caused by malicious intent. no criminal mastermind. well intentioned programmers who made mistakes, didn't check thoroughly and didn't assess risk. \textbf{learn why did faulure accur, what was the risk and how it could have been avoided, what can we change so it never happens again}. 
SE is about developing and utilizing engineering principles to produce software, learning from mistakes and enactivng systemic change to avoid or mitigate risk. SE concerned with \textit{process over product, tools to help with software development, improving development efficiency}. 
\textbf{LECTURE 2}
Standish Group CHAOS Report 1995:
16.2\%of software projects are successful: On time, on budget;
52.7\% of software challenged: Over budget and/or over time, Fewer features than specified;
31.1\%Failure;
189 percent initial cost. twice as long as expected. only 61 percent of features 
Properties of good software: work as speicifed, does what the customer asked for, stable/predictable (bug free), maintainable, cost effecitve. 
Six major steps of software: specification, design, development, testing, deployment, maintianance. \textbf{ad-hoc} building and fix, cowboy coding: 1) build first version 2) modify until customer is happy. 
Software life cycle models: constructs that dictate life cycles models. disclaimer, no one adheres to a model perffectly and hybrid models exist. 
Waterfall theory: each phase (req gathering, system design, implementation,testing, deployment, maintiance) falls into the next (e.g. fully complete requirements and design before any code is written, no new features after coding starts). Simple model, easy to manage, clear deliverables, process don't overlap. disadvantage of series design flaws may not be discovered until testing, no working code until late in the model. immobile to requirement changes. Iterative waterfall model: overcomes some of the inflixibility of waterfall, but going back phases is expensive and time consuming, should be avoided. 
Incremental model: build 1,2,3. build on a system incrementally (consumers get to see product as it is conconstructed). doesn't offset need for heavy planning at the beginning. more expensive than waterfall. problems with earlier versions can arise later. 
Iterative prototyping: building prodtotypes of efeatures get short term feedbacks in gaming. Protypes are vertical (fully demonstrates small subset of features, lacks features not shown completely) or horizontal (show overview of system, ui prototypes are great examples). 
Different types of prototypes: throwaway (costly but prevents long term instability, evolutionary reduces long term cost, but less mtaintainbable, incremental, extreme. 
Incremental vs iterative (incremental is parts of mona lisa painting, iterative is outlines and filling it in further and further). 
Agile isn't a method: it is a collection of methods that fits the agile manifesto. Individuals and interactions over Processes and tools Working software over Comprehensive documentation Customer collaboration over Contract negotiation Responding to change over Following a plan
That is, while there is value in the items on the right, we value the items on the left more. 
Scrum: product backlog, sprint backlong, 2-4 week period (24 hrs  scrum), potentially shippable product increment. Short, information-based, not problem-solving (problem solving and questions offline after meeting). Three questions: what did I accomplish yesterday? what will i do today? what obstacles are impeding my progress? 
Benefits of agile: open to design changes. response to requirements changes more easily than planned methods. large amount of face to face tim. incremental releases keep customers informed and happy. fixed time scales of relases. has a better track record in code quality and speed of development. disadvantages: collaboration is time consumeing. requires heavy coustomer interatction, evolving requirements mak prdicting effort difficult, scalability concerns, code  quality can degrade over srpints, turnove.r BEST APPROACH IS AGILE. LEAN IS NOT AN ALTERNATIVE TO AGILE (about learning eliminating waste). 
\textbf{Requirements engineering} (hardest thing is deciding what to build). cost of change increases over time. Two types: HIGH LEVEL (business requirements); what benefits will cust. cget and users get. LOW LEVEL: what will system do, how well? 
Steps: Find problem to solve, do concept exploration to determine if software is a good solution, determine a set of requirements to solve the problem, specifiy the requireements specifically, validate requirements. 
Goals: defint the problem, explore constraints, understand operation environment, address high level details of solution. determine feasibility \textbf{3 questions to ask} shoud system be built, must it be built,can it be built. should it be built (is problem important, how frequent is the porblem, is the market for the problem large enough to justify the cost, would automated solution be better). must a system be built (is the solution already out there). can a system be built (what is the feasibility, two types: technical and political e.g. workforce, management, finances, laws). Cost benefit analysis are there resources. feasibility is fin flux. technology improves, companies change. \textbf{requirements engineeringp rocess: elicitation, specification, validation}. elicityation: find a consumer with problem, get list of requirements. asking what you want doesn't work, need specifics. stakeholders don't know anything, devs may not understand system requirements, diff stakeholders describe same thing different ways. reqs change. INTERVIEW (close interviews, open interviews, jargon heavy, obvious info not obvious, avoid preconceived ideas about the software. visual prototypes for interfaces), ETHANOGRAPHY (observe day to day stifels innovation), user stories (process by which a task will be completed or used, narrative). Scenarios: initial assumption, description of natural flow of events. description of what can go wrong, other activities, description of end result.
User story guidelines: e.g. as a student user, i can create a new question and specify the folders, summary, an details. needs to be discrete but not precise, estimable (possible to estimate work needed), traceable (possible to know which parts of system satisfy the requirement), testable(so you know its done). \textbf{requirements are features, function, capability, property a software product must have and it must be testable!}. eliciting requirements by close ended (specific and detailed), open ended, scenario (lets customer talk thru seq. of interactions), and probing (forces customer to think about justification for each requirmeents). requirements spec is much more specific than concept exploration, concept exploration determines what software CAN do, req specs are what software will do. 
2 stakeholders, user requs (consumer), system reqs(developer). User Requirements are requirements designed
for review by end user, but may often lack details. Use broad statements to convey intent. These have to be turned into System Requirements. System Requirement high detailed list of requirements for a system.
Functional: Describe the services/ features/ operation of the system. (user should be able to search for all clinics. system wil lgenerate daily report listing all appointmentso f the day)
Non-functional: Constraints under which the system operations (user should be able to use after 1 hr of training. list should load within 0.5 s)
Godo requirmeents: complete, testable, traceable, consistent, concise, readable, feasible, changeable
What is good software: ISO 9126: functionality (satisfies needs), reliable (correctly operates), usability (effort eneded to use software), efficiency, relation between performance and amount of resources, portability (can be transfered from 1 env to another). Internal quality of maintainability (can be uderstood), changeability (can be asily modified), stability, and testability. \textbf{how to we achieve internal quality} DESIGN.
What is system modeling: process of developing abstract models of a system. each abstract model presents a different view of that system. system modeling often involves diagramming interaction and processes. system model isn't complete rep of system, it is an abstraction not a translation. Can be used during design, implementaiton, and after implementation. external perspective is to model the content or environment of the system and how it gets used by the user. interaction between system and environment... \textbf{structural} model the organization of system and data, \textbf{behavioral} model the dynamic behavior of system and how it responds to events. 
UML diagrams (unified modeling language). activity diagrams show all activities in process. use case diagrams show interactions between system and environment. state diagrams show how system reacts to events. class diagrams show object classes and realtionship. sequence diagram shows interactions between actors and complenets in the system. \includegraphics[width=\columnwidth]{uml}
SOFTWARE DESIGN:
Essential difficulties: complexity: software not buiilt on repeatable parts, building two pieces of software not like building 2 cares. complexitiy is inherent to software. no one person will fully understand an entire system \textbf{conceptual integirty} (many people agreeing on understanding) is impossible. 
Conformity: software must integrate with different interfaces, users, systems, requires more complexity
Changeability: infinitely malleable. manufactured things are rarely changed after manufacturing (in software however change is the norm). New users discover product, pushing edge chases. changing tech also creates change. 
Invisibility: we can have several different diagrams mapping the same system, overlaying graphs would be complicated. 
How do we organize code \textbf{modularity, functional independence} and how should we expose functionality (\textbf{abstraction, information hiding}). 
Technical debt is the cost of poor deisgn decisions becomes worse over time. a form of delayed gratification, only for whatever the opposite of gratification is ``delayed screwing yourself". Lack of documentation or changeability. 
Incremental changes is the repeated process of adding to code base. used in development by adding new features, expanding or improving existing features. maintenance fixing ffedfects reducing technical debt. 
Incremental change process (before writing code). initiation (analyze user stores and change requirements and extract concepts). concept location is locating concepts in the source code. impact analysis is the set of classes/methods likely to be affected by teh change. prefactoring is to refactor to make changes easier. DURING THE CODE actualization is the ipmlementation by writing new code and incorporating it into the system. propagation is to propagete the changes thru the system. post factoring, new baseline is toe commit the changes. 
Modularity. split stuff up (Tweet class stores records and calls TweetFinder and TweeetTime). UNDERSTAND THE ASSUMPTIONS YOUR INTERFACE MAKES. \textbf{single responsibility principle} each module should only have one reason to change. should only address 1 part of the requirements. cohesion: all functionality should be closely related, breaking into smaller modules is gooood. 
Functional indepdence. example: if i find the tweet within the tweet module i have to know a lot about the state. if i have a separate module i only need to know about the interface. Loose coupling good, tight compling bad (requires more info than needed, modules depend on each other and share global data). 
Abstraction is to program an interface. what they do not how they do it. have functions input output based. Abstract data types (just need a list, doesn't matter what). things to avoid. THE GOD CLASS
Architectural patterns: Pattern is a way of presenting, sharing, and reusing knowledge about a software system. a pattern is an architectural pattern is an abstract description of good practice with the pattern. this good practice description comes from yeears of experiences. this description clearly identify if pattern is appropriate and where it isn't. details advantages and disadvantages. \textbf{monolithic} single module or small number of tightly coupled modules, simple to develop/scale/deploy. larger code base is intimidating, difficult to learn, and dev is difficult. \textbf{component based} is the collection of off the  shelf moduels that provide various services. these modules are glued together. having multiple components in the same view is difficult. \textbf{client-server} system is presented as a set of services. service is represented by a separate server. multiple clients access each server to use the service. service access backend data structure. some network is used to access these services. used when data in shared db needs to be accessed from multiple locations and if the load on the system is variable. allws for dist of services across network. general functiaonities can be available to add clients and doesn't need to be implemented on all services. individiauls services can be modified independently. disadvatnages. limited by network and unpredictable (security stuff also). \textbf{software as a service} client-server + component based. growing use of web based interfaces makes the market potentially large and system agnostic. all problems of web dev. \textbf{MVC} Model view controller. model manages data. view manages information for the user. controller manages user interactions. separates presentation and interaction from data. 3 models interact to control, view, and manupulate data. allow multiple ways to view data, useful when requirements are unknown. Advnatages allow the data to be indep of the representation. supports using data in dif ways. disad: means more code though. \textbf{layered architechture} has presentation layer (UI), application service/interface layer (ui management), business logic layer that enforces real world limitations on data, data access layer interface with db, and system later OS interfaces. In theory same separation and indep of MVC, can change each layer without changing other ones. users are the top, low level bottom. interactions have to travel up and down a layer. use when building on otp of existing system of services or data (good for dist dev as each team can work on a layer, good for sec). advantage is replacement of layers, redundant actions are in all layer. disadvantage is that making diff between layers is hard, interface pass thru is hard. requirements changes may be needed. more code. 
\begin{lstlisting}[language=Java]
public class StudentMVCDemo {
public static void main(String[] args) {
Student model  = retriveStudentFromDatabase();
StudentView view = new StudentView();
StudentController controller = new StudentController(model, view);
controller.updateView();
controller.setStudentName("John");
controller.updateView();
}
private static Student retriveStudentFromDatabase(){
Student student = new Student();
student.setName("Robert");
student.setNumber(10);
return student;
}
}
\end{lstlisting}
\textbf{Groups of design patterns}
Creation patterns: handle obejct creation and instantiation. Structural patterns bring existing objects together. behavioral patterns give a way to manifest flexible behavior. \textbf{Iterators} allow you to visit all elements of a collection one at a time. if you implement a collection, must have iterator. has functional independence and information hiding (don't have to know how collection is structured, just need to know if it works) it is a MEME. Creational patterns used that hide or limit constructor usage. Singleton: only one instance at a single time. that instance can be shared across multiple modules (e.g. logger). never use singleton if you need multiple. \textbf{Factory pattern} is when you might need to use a class on the flight by combining existing pieces. Interchagable pieces of a system and put them together! Abstract factory pattern, having indepdent factories is bad. more classes = more complexity so the solution is to build several factories where the programmer can ``order" the class they want. have all the factories share an interaface so ordering is simple. 
\begin{lstlisting}
// SINGLETON
public class Logger {
private static BufferedWriter logWriter;
private static Logger instance;
private Logger(){
logWriter = new BufferedWriter(new FileWriter("log.txt"));
}
public static Logger getInstance(){
if (instance == null) {
instance = new Logger();
}
return instance;
}
public void writeToLogFile(String s) {
}
}
public class SomeOtherClass {
public static void logExample(){
Logger log = Logger.getInstance();
log.writeToLogFile("Inside some other class");
}
}
// ABSTRACT FACTORY
public abstract class AbstractFactory {
abstract Color getColor(String colorType);
abstract Shape getShape(String shapeType);
}
public class AbstractFactoryDemo {
public static void main(String[] args) {
AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
Shape shape1 = shapeFactory.getShape("CIRCLE");
shape1.draw();
Shape shape2 = shapeFactory.getShape("RECTANGLE");
shape2.draw();
AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
Color color1 = colorFactory.getColor("RED");
color1.fill();
Color color2 = colorFactory.getColor("BLUE");
color2.fill();
}
}
\end{lstlisting}
Bridge pattern is decoupling an abstraction from its implementation so that the two can vary indepdently. maintain spearate inheritance hierarchies that ally a client to assumble combinations as needed. have an abstract implmentor that selects a concrete implmentor. Shapes. 
\begin{lstlisting}
List
<Shape>
shapes = . . .
shapes.add(new Circle(50, 50, 20, new GrayscaleRenderer());
shapes.add(new Rectangle(80,80,120,120,
new ColorRenderer());
for (Shape s : shapes)
s.draw(); // use the interface
interface Renderer {
Void drawCircle(int x, int y, int radius); Void drawRectangle(int x1, int x2,
int y1, int y2);
} class ColorRenderer implements Renderer {
. . . }
class GrayscaleRenderer implements Renderer {
. . . }
// DECORATOR
abstract class Ingredient implements Drinkable{
protected Drinkable base; public Ingredient(Drinkable b) {
base = b;}
double price {return base.price();} String toString {
return base.toString();}
}
\end{lstlisting}
bid ball of mud is software that lacks clear structure or architecture. system are appended haphazardly and expeditiously. internal software qual deteriorates. God class sucks. 
Review: Creational Patterns handle object creation and instantiation Singleton - only one instance can exist at a time, shared by multiple modules without those modules being aware of each other Factory - defer instantiation to subclass, define interface for creating object, but let subclasses decide which class to instantiate Abstract Factory - have several factories share interface to make 'ordering' simple. Structural Patterns bring existing objects together Bridge maintain separate inheritance hierarchies that ally a client to assemble combinations as needed, abstract 'implementer' selects a concrete implementer Decorator on the fly object creation Adaptor adapt existing class/object to new interface without changing underlying class (useful to update interfaces while minimizing side effects/propagation of changes) Facade hide a complicated interface or set of interfaces with a single interface (useful to hide complex interfaces that are hard to use correctly). Behavioral Patterns give a way to manifest flexible behavior Iterator allow you to visit all elements of collections one at a time, functional independence, information hiding Observer Objects need to notify varying list of objects that some event has occurred (variable change method called), possible that you'll want to link objects to notify each other at runtime Strategy class that represents the strategy and pass instance to method that implements rest of algorithm	
\end{multicols*}
\end{landscape}
\end{document}
